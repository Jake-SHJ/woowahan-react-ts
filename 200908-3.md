## Q&A 정리

- 상태만 관리하는 컴포넌트, 렌더링만 하는 컴포넌트의 사용
- context api => 전역 상태의 관리, provider에는 적용하기 좋음, 상태 의존성이 높아짐
- 일관성이 중요 (성능 문제를 일으키지 않는 한도에서) > 얻는 것이 있으면, 잃는 것이 생긴다 (Redux에서 store 하나에 모든 상태를 담는 것에 대한 질문)
- virtual DOM library, 구현체 찾아서 Diff 알고리즘에 대해 공부해 보면 좋음

## Redux

- publish/subscribe pattern을 구현한 것, React와는 무관하다.

## React

- _왜 이렇게 만들었는가?_ 에 대한 의문을 가져라
- 공유된 코드를 활용해서 복기를 해 볼 것
- 고치기 쉽게 빠르게 파악할 수 있는 코드 구조는 무엇이 있을까? (어떤 것이 좋은 아키텍처인가?)
- 근본 원칙: 같은 것끼리 묶고, 다른 것은 분리하자 => 그렇다면 어떤 게 같은 것이고, 어떤 게 다른 것인가? (추상화 레벨의 차이)
- 이름만 잘 지어도 70%는 먹고 들어간다. (네이밍의 중요성)
- 너무 높은 것을 추구하면, 기본적인 것에 소홀해 질 수 있다.

# React concept

- real DOM의 api는 추상화 수준이 높지 않음 => 직접적으로 다루면 복잡도 상승을 피할 수 없음
- 문자열 > 구조가 없어서 다루기 까다롭다 > 좀 더 다루기 쉬운 구조는? DOM Tree! > DOM Tree도 low level > 더 다루기 쉬운건? Virtual DOM!
- 익숙한 markup language 형태로 다루자 > JSX

# React 구현

- 까다로운 문자열을 JS에서 다루기 쉬운 객체로 바꿔보자 > vdom의 구현
- compile time과 run time에 대한 이해가 필요하다
- babel 최상단 /_ @jsx a _/ a를 이용한 jsx 문법이 된다
- built-in 컴포넌트와 시용자 컴포넌트의 구분 => 대문자로 시작하는가 안하는가 (바벨을 통해 확인 가능 > 소문자 일 때 문자열로 들어가지만, 대문자로 시작하면 함수 그자체로 들어간다)
- _라이브러리의 코드를 열어볼 땐, 초창기로 돌아가서 내용을 확인하는 것이 좋다. (이미 업데이트가 많이 된 라이브러리는 방어 로직 등 컨셉을 이해하기 어렵다)_

# 컴포넌트와 상태

- 초기의 컴포넌트는 class의 형태, props를 constructor가 받고, React.Component의 render에서 class의 인스턴스를 생성하고 렌더링
- 루트가 하나인 트리 구조일 수 밖에 없다 => 객체의 구조를 가지기 때문
- 왜 class, 함수형의 두 가지 형태를 갖게 되었는가? => 상태를 다루기 위함
- 함수형 컴포넌트는 상태를 가질 수 없다 => 변수가 매번 초기화 되기 때문 => 외부로부터 상태를 받아서 그리기만 한다면 함수형을 사용
- class 컴포넌트는 객체이므로 react 내부에서 파기하지 않는 이상 상태를 유지할 수 있다 => 상태를 컴포넌트 내부에서 직접 다룬다면 class를 사용
- class 컴포넌트의 상태 변화에 따라 모든 DOM을 다 변경할 수는 없기 때문에, Life cycle을 가지게 됨

# Hooks

- const [valueParameter, dispatcher] = useState(valueArgument); 의 구조를 가짐 (useState가 배열을 반환하기 때문에 구조분해할당 형식으로 작성이 가능하다)
- 어떤 마법이 일어나는걸까? react가 주는 setState와 같은 맥락? => createElement에서 노드가 함수면 호출 = Component 호출 > useState 호출 (해당 컴포넌트에 속하는 상태임을 인지가 가능) > 전역 배열에 저장 (컴포넌트를 키로 하여) => 컴포넌트에 의해 인덱싱이 되기 때문에 리액트 컴포넌트에서 호출되어야 하고, 조건문이나 반복문에서 사용하는 것을 지원하지 못한다.
